// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cards.sql

package models

import (
	"context"
)

const createCard = `-- name: CreateCard :one
INSERT INTO cards (name,
                   issuer,
                   last4_digits,
                   expiry_date,
                   default_reward_rate,
                   card_type,
                   user_id -- Added user_id
)
VALUES (?, ?, ?, ?, ?, ?, ?) -- Added placeholder for user_id
RETURNING id, name, issuer, last4_digits, expiry_date, default_reward_rate, card_type, user_id, created_at, updated_at
`

type CreateCardParams struct {
	Name              string   `json:"name"`
	Issuer            string   `json:"issuer"`
	Last4Digits       string   `json:"last4_digits"`
	ExpiryDate        string   `json:"expiry_date"`
	DefaultRewardRate *float64 `json:"default_reward_rate"`
	CardType          string   `json:"card_type"`
	UserID            int64    `json:"user_id"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (*Card, error) {
	row := q.queryRow(ctx, q.createCardStmt, createCard,
		arg.Name,
		arg.Issuer,
		arg.Last4Digits,
		arg.ExpiryDate,
		arg.DefaultRewardRate,
		arg.CardType,
		arg.UserID,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Issuer,
		&i.Last4Digits,
		&i.ExpiryDate,
		&i.DefaultRewardRate,
		&i.CardType,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM cards
WHERE id = ? AND user_id = ?
`

type DeleteCardParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

// Add a DeleteCard query as well, ensuring user_id check
func (q *Queries) DeleteCard(ctx context.Context, arg DeleteCardParams) error {
	_, err := q.exec(ctx, q.deleteCardStmt, deleteCard, arg.ID, arg.UserID)
	return err
}

const getCardByIDAndUser = `-- name: GetCardByIDAndUser :one
SELECT id, name, issuer, last4_digits, expiry_date, default_reward_rate, card_type, user_id, created_at, updated_at FROM cards
WHERE id = ? AND user_id = ?
`

type GetCardByIDAndUserParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetCardByIDAndUser(ctx context.Context, arg GetCardByIDAndUserParams) (*Card, error) {
	row := q.queryRow(ctx, q.getCardByIDAndUserStmt, getCardByIDAndUser, arg.ID, arg.UserID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Issuer,
		&i.Last4Digits,
		&i.ExpiryDate,
		&i.DefaultRewardRate,
		&i.CardType,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getCardByNameIssuerAndUser = `-- name: GetCardByNameIssuerAndUser :one
SELECT id, name, issuer, last4_digits, expiry_date, default_reward_rate, card_type, user_id, created_at, updated_at FROM cards
WHERE name = ? AND issuer = ? AND user_id = ? -- Added user_id filter
LIMIT 1
`

type GetCardByNameIssuerAndUserParams struct {
	Name   string `json:"name"`
	Issuer string `json:"issuer"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) GetCardByNameIssuerAndUser(ctx context.Context, arg GetCardByNameIssuerAndUserParams) (*Card, error) {
	row := q.queryRow(ctx, q.getCardByNameIssuerAndUserStmt, getCardByNameIssuerAndUser, arg.Name, arg.Issuer, arg.UserID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Issuer,
		&i.Last4Digits,
		&i.ExpiryDate,
		&i.DefaultRewardRate,
		&i.CardType,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listCardsByUser = `-- name: ListCardsByUser :many
SELECT id, name, issuer, last4_digits, expiry_date, default_reward_rate, card_type, user_id, created_at, updated_at FROM cards
WHERE user_id = ? -- Added user_id filter
ORDER BY name ASC
`

func (q *Queries) ListCardsByUser(ctx context.Context, userID int64) ([]*Card, error) {
	rows, err := q.query(ctx, q.listCardsByUserStmt, listCardsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Issuer,
			&i.Last4Digits,
			&i.ExpiryDate,
			&i.DefaultRewardRate,
			&i.CardType,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCard = `-- name: UpdateCard :one
UPDATE cards
SET name = ?,
    issuer = ?,
    last4_digits = ?,
    expiry_date = ?,
    default_reward_rate = ?,
    card_type = ?
WHERE id = ? AND user_id = ? -- Added user_id filter
RETURNING id, name, issuer, last4_digits, expiry_date, default_reward_rate, card_type, user_id, created_at, updated_at
`

type UpdateCardParams struct {
	Name              string   `json:"name"`
	Issuer            string   `json:"issuer"`
	Last4Digits       string   `json:"last4_digits"`
	ExpiryDate        string   `json:"expiry_date"`
	DefaultRewardRate *float64 `json:"default_reward_rate"`
	CardType          string   `json:"card_type"`
	ID                int64    `json:"id"`
	UserID            int64    `json:"user_id"`
}

func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) (*Card, error) {
	row := q.queryRow(ctx, q.updateCardStmt, updateCard,
		arg.Name,
		arg.Issuer,
		arg.Last4Digits,
		arg.ExpiryDate,
		arg.DefaultRewardRate,
		arg.CardType,
		arg.ID,
		arg.UserID,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Issuer,
		&i.Last4Digits,
		&i.ExpiryDate,
		&i.DefaultRewardRate,
		&i.CardType,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
